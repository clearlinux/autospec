#!/usr/bin/python3
#
# specfile.py - part of autospec
# Copyright (C) 2016 Intel Corporation
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Write spec file
#

import os
import types
import re
import time
from collections import OrderedDict

from libautospec import config

from libautospec.util import _file_write


class Specfile(object):
    """
    Holds data and methods needed to write the spec file.
    """

    def __init__(self, url, version, name, release):
        self.url = url
        self.version = version
        self.name = name
        self.release = release
        self.keepstatic = False
        self.urlban = ""
        self.no_autostart = False
        self.specfile = None
        self.sources = {"unit": [], "gcov": [], "tmpfile": [], "archive": []}
        self.source_index = {}
        self.default_sum = ""
        self.licenses = []
        self.packages = OrderedDict()
        self.requires = set()
        self.buildreqs = []
        self.patches = []
        self.default_desc = ""
        self.locales = []
        self.default_pattern = ""
        self.autoreconf = False
        self.extra_make = ""
        self.extra_make_install = ""
        self.tarball_prefix = ""
        self.gcov_file = ""
        self.rawname = ""
        self.golibpath = ""
        self.archive_details = {}
        self.prep_append = []
        self.need_avx2_flags = False
        self.tests_config = ""
        self.subdir = ""
        self.install_macro = "%make_install"
        self.disable_static = "--disable-static"
        self.extra_cmake = ""
        self.make_install_append = []
        self.excludes = []
        self.keyid = ""
        self.email = ""
        self.cargo_bin = False

    def write_spec(self, path):
        """
        write spec file
        """
        self.specfile = open("{}/{}.spec".format(path, self.name),
                             "w", encoding="utf-8")
        self.specfile.write_strip = types.MethodType(_file_write, self.specfile)

        # spec file comment header
        self.write_comment_header()

        if self.keepstatic:
            self._write("%define keepstatic 1\n")

        # general package header
        self.write_nvr()
        self.write_sources()
        self.write_summary()
        self.write_license()

        self.write_main_subpackage_requires()
        self.write_buildreq()
        self.write_strip_command()
        self.write_patch_header()

        # main package extra content
        self.write_description()
        self.write_files_header()

        # build instructions
        self.write_buildpattern()

        # scriplets
        self.write_scriplets()

        # %files
        self.write_files()
        self.write_lang_files()

        self.specfile.close()

    def write_comment_header(self):
        """
        Write comment header to spec file
        """
        self._write("#\n")
        self._write("# This file is auto-generated. DO NOT EDIT\n")
        self._write("# Generated by: autospec.py\n")
        self._write("#\n")

        # if package was verified, write public key information
        if self.keyid:
            sig_msg = "# Source0 file verified with key 0x{}".format(self.keyid)
            if self.email:
                sig_msg += " ({})".format(self.email)

            self._write_strip(sig_msg)
            self._write_strip("#")

    def write_nvr(self):
        """
        Write name, version, and release information.
        """
        if self.urlban:
            self.url = re.sub(self.urlban, "localhost", self.url)
        self._write("Name     : {}\n".format(self.name))
        self._write("Version  : {}\n".format(self.version))
        self._write("Release  : {}\n".format(str(self.release)))
        self._write("URL      : {}\n".format(self.url))
        self._write("Source0  : {}\n".format(self.url))

    def write_sources(self):
        """
        Append additional source files - systemd unit files, gcov, and
        additional source tarballs are the currently supported file types.
        """
        for count, source in enumerate(sorted(self.sources["unit"] +
                                              self.sources["archive"] +
                                              self.sources["tmpfile"] +
                                              self.sources["gcov"])):
            self.source_index[source] = count + 1
            self._write("Source{0}  : {1}\n".format(count + 1, source))

        # if package is verified, include the signature in the source tarball
        if self.keyid and config.signature:
            self._write_strip("Source99 : {}".format(config.signature))

    def write_summary(self):
        """
        Write package summary to spec file
        """
        self._write("Summary  : {}\n".format(self.default_sum.strip()))
        self._write("Group    : Development/Tools\n")

    def write_license(self):
        """
        Write license information to spec file
        """
        self._write("License  : {}\n".format(" ".join(sorted(self.licenses))))

    def write_main_subpackage_requires(self):
        """
        Write subpackage build requirements
        """
        for pkg in self.packages:
            if pkg == "autostart" and self.no_autostart:
                continue
            if pkg in ["ignore", "main", "dev", "active-units", "extras",
                       "lib32", "dev32"]:
                continue
            self._write("Requires: {}-{}\n".format(self.name, pkg))

        for pkg in sorted(self.requires):
            self._write("Requires: {}\n".format(pkg))

    def write_buildreq(self):
        """
        Write build requirements
        """
        for req in sorted(self.buildreqs):
            self._write("BuildRequires : {}\n".format(req))

    def write_strip_command(self):
        """ Write commands to prevent stripping binary if requested """
        if config.config_opts['nostrip']:
            self._write("# Suppress stripping binaries\n")
            self._write("%define __strip /bin/true\n%define debug_package %{nil}\n")

    def write_patch_header(self):
        """
        Write patch list header
        """
        for count, patch in enumerate(self.patches):
            self._write("Patch{0}: {1}\n".format(count + 1, patch.split()[0]))

    def write_description(self):
        """
        Write package description
        """
        self._write("\n%description\n{}\n".format(self.default_desc.strip()))

    def write_files_header(self):
        """
        Write file headers to spec file
        """
        groups = {}
        groups["dev"] = "Development"
        groups["bin"] = "Binaries"
        groups["lib"] = "Libraries"
        groups["doc"] = "Documentation"
        groups["data"] = "Data"

        deps = {}
        deps["dev"] = ["lib", "bin", "data"]
        deps["dev32"] = ["lib32", "bin", "data", "dev"]
        deps["bin"] = ["data", "config", "setuid", "attr"]
        deps["lib"] = ["data"]
        deps["lib32"] = ["data"]
        deps["python"] = ["legacypython", "python3"]

        # migration workaround; if we have a python3 or legacypython package
        # we add an artificial python package

        if ("python3" in self.packages or "legacypython" in self.packages) and ("python" not in self.packages):
            self.packages["python"] = set()

        provides = {}
        provides["dev"] = ["devel"]

        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main"]:
                continue

            self._write("\n%package {}\n".format(pkg))
            self._write("Summary: {} components for the {} package.\n"
                        .format(pkg, self.name))
            if pkg in groups:
                self._write("Group: {}\n".format(groups[pkg]))
            else:
                self._write("Group: Default\n")

            for dep in deps.get(pkg, []):
                if dep in self.packages:
                    self._write("Requires: {}-{}\n".format(self.name, dep))

            for prov in provides.get(pkg, []):
                self._write("Provides: {}-{}\n".format(self.name, prov))

            if pkg == "python":
                if self.name != self.name.lower():
                    self._write("Provides: {}-python\n".format(self.name.lower()))

            if pkg == "python3":
                self._write("Requires: python3-core\n")

            if pkg == "legacypython":
                self._write("Requires: python-core\n")

            self._write("\n%description {}\n".format(pkg))
            self._write("{} components for the {} package.\n".format(pkg, self.name))
            self._write("\n")

    def write_buildpattern(self):
        """
        Write build pattern to spec file.

        Currently depends on buildpattern.py due to pattern-matched methods
        """
        self._write_strip("\n")
        pattern_method = getattr(self, 'write_{}_pattern'.format(self.default_pattern))
        if pattern_method:
            pattern_method()

        self.write_source_installs()
        self.write_make_install_append()
        # self.write_systemd_units()

    def write_scriplets(self):
        """
        Write post and pre scripts to spec file
        """
        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main", "locales"]:
                continue
            for script in ["post", "pre"]:
                content = config.read_conf_file("{}.{}".format(script, pkg))
                if content:
                    self._write("\n%{0} {1}\n".format(script, pkg))
                    content = ['{}\n'.format(l) for l in content]
                    self.specfile.writelines(content)

    def write_files(self):
        """
        Write %files section to spec file
        """
        self._write("\n%files\n")
        self._write("%defattr(-,root,root,-)\n")
        if "main" in self.packages:
            for filename in sorted(self.packages["main"]):
                self._write("{}\n".format(self.quote_filename(filename)))

        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main", "locales"]:
                continue

            self._write("\n%files {}\n".format(pkg))
            self._write("%defattr(-,root,root,-)\n")
            for filename in sorted(self.packages[pkg]):
                self._write("{}\n".format(self.quote_filename(filename)))

    def write_lang_files(self):
        """
        Write lang files to spec
        """
        if not self.locales:
            return

        self._write("\n%files locales")
        for lang in self.locales:
            self._write(" -f {}.lang".format(lang))

        self._write("\n%defattr(-,root,root,-)\n\n")

    def write_lang_c(self, export_epoch=False):
        """Write C language pattern"""
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("export LANG=C")
        if export_epoch:
            # time.time() returns a float, but we only need second-precision
            self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        if config.config_opts['asneeded']:
            self._write_strip("unset LD_AS_NEEDED\n")

    def write_proxy_exports(self):
        """Write proxy exports to localhost to block build/check calls to internet"""
        self._write_strip("export http_proxy=http://127.0.0.1:9/")
        self._write_strip("export https_proxy=http://127.0.0.1:9/")
        self._write_strip("export no_proxy=localhost,127.0.0.1,0.0.0.0")

    def write_make_line(self):
        """
        Write make line to spec file

        make V=1 <config.parallel_build> <extra_make>
        """
        self._write_strip("make V=1 {}{}".format(config.parallel_build, self.extra_make))

    def write_prep(self, ruby_pattern=False):
        """Write prep section to spec file"""
        self._write_strip("%prep")
        for archive in self.sources["archive"]:
            self._write_strip("tar -xf %{{SOURCE{}}}".format(self.source_index[archive]))
        if self.sources["archive"]:
            self._write_strip("cd ..")
        if ruby_pattern:
            self._write_strip("gem unpack %{SOURCE0}")
            self._write_strip("%setup -q -D -T -n " + self.tarball_prefix)
            self._write_strip("gem spec %{{SOURCE0}} -l --ruby > {}.gemspec".format(self.name))
        else:
            if self.default_pattern == 'R':
                self._write_strip("%setup -q -c -n " + self.tarball_prefix)
            else:
                self._write_strip("%setup -q -n " + self.tarball_prefix)

        for archive in self.sources["archive"]:
            self._write_strip('mkdir -p %{{_topdir}}/BUILD/{0}/{1}'
                              .format(self.tarball_prefix,
                                      self.archive_details[archive + "destination"]))
            self._write_strip('mv %{{_topdir}}/BUILD/{0}/* %{{_topdir}}/BUILD/{1}/{2}'
                              .format(self.archive_details[archive + "prefix"],
                                      self.tarball_prefix,
                                      self.archive_details[archive + "destination"]))
        self.apply_patches()
        if config.config_opts['32bit']:
            self._write_strip("pushd ..")
            self._write_strip("cp -a {} build32".format(self.tarball_prefix))
            self._write_strip("popd")
        if config.config_opts['use_avx2']:
            self._write_strip("pushd ..")
            self._write_strip("cp -a {} buildavx2".format(self.tarball_prefix))
            self._write_strip("popd")
        self._write_strip("\n")
        self.write_prep_append()

    def write_prep_append(self):
        """write out any custom supplied commands at the very end of the %prep section"""
        if self.prep_append and self.prep_append[0]:
            for line in self.prep_append:
                self._write_strip("{}\n".format(line))

            self._write_strip("\n")

    def write_variables(self):
        """Write variable exports to spec file"""
        flags = []
        if config.config_opts['use_clang']:
            self._write_strip("export CC=clang\n")
            self._write_strip("export CXX=clang++\n")
            self._write_strip("export LD=ld.gold\n")
        if config.config_opts['optimize_size']:
            if config.config_opts['use_clang']:
                flags.extend(["-Os", "-ffunction-sections", "-fdata-sections"])
            else:
                flags.extend(["-Os", "-ffunction-sections", "-fdata-sections", "-fno-semantic-interposition"])
        if config.config_opts['security_sensitive']:
            flags.append("-fstack-protector-strong")
        if self.need_avx2_flags:
            flags.extend(["-O3", "-march=haswell"])
        if config.config_opts['insecure_build']:
            self._write_strip('export CFLAGS="-O3 -g -fopt-info-vec "\n')
            self._write_strip("unset LDFLAGS\n")
        if config.config_opts['conservative_flags']:
            self._write_strip('export CFLAGS="-O2 -g -Wp,-D_FORTIFY_SOURCE=2 '
                              "-fexceptions -fstack-protector "
                              "--param=ssp-buffer-size=32 -Wformat "
                              "-Wformat-security -Wno-error  "
                              " -Wl,-z,max-page-size=0x1000 -m64 "
                              '-march=westmere -mtune=haswell"\n')
            self._write_strip("export CXXFLAGS=$CFLAGS\n")
            self._write_strip("unset LDFLAGS\n")
        if config.config_opts['use_clang']:
            self._write_strip("unset LDFLAGS\n")
        if config.config_opts['funroll-loops']:
            if config.config_opts['use_clang']:
                flags.extend(["-O3"])
            else:
                flags.extend(["-O3", "-fno-semantic-interposition", "-falign-functions=32", "-fno-math-errno", "-fno-trapping-math"])
        if config.config_opts['use_lto']:
            flags.extend(["-O3", "-flto=4", "-ffat-lto-objects"])
            self._write_strip("export AR=gcc-ar\n")
            self._write_strip("export RANLIB=gcc-ranlib\n")
            self._write_strip("export NM=gcc-nm\n")
        if config.config_opts['fast-math']:
            flags.extend(["-ffast-math", "-ftree-loop-vectorize"])
        if config.config_opts['pgo']:
            flags.extend(["-O3", "-fprofile-use", "-fprofile-dir=pgo", "-fprofile-correction"])
        if self.gcov_file:
            flags = list(filter(("-flto=4").__ne__, flags))
            flags.extend(["-O3", "-fauto-profile=%{{SOURCE{0}}}".format(self.source_index[self.sources["gcov"][0]])])
        if flags:
            flags = sorted(list(set(flags)))
            self._write_strip('export CFLAGS="$CFLAGS {0} "\n'.format(" ".join(flags)))
            self._write_strip('export FCFLAGS="$CFLAGS {0} "\n'.format(" ".join(flags)))
            self._write_strip('export FFLAGS="$CFLAGS {0} "\n'.format(" ".join(flags)))
            # leave the export CXXFLAGS line open in case
            self._write('export CXXFLAGS="$CXXFLAGS {0} '.format(" ".join(flags)))
            if config.config_opts['broken_c++']:
                self._write('-std=gnu++98')
            # close the open quote from CXXFLAGS export and add newline
            self._write('"\n')

        if config.profile_payload and config.profile_payload[0] and not self.need_avx2_flags:
            genflags = []
            useflags = []
            genflags.extend(["-fprofile-generate", "-fprofile-dir=pgo", "-fprofile-update=atomic"])
            useflags.extend(["-fprofile-use", "-fprofile-dir=pgo", "-fprofile-correction"])

            self._write_strip('export CFLAGS_GENERATE="$CFLAGS {0} "\n'.format(" ".join(genflags)))
            self._write_strip('export FCFLAGS_GENERATE="$FCFLAGS {0} "\n'.format(" ".join(genflags)))
            self._write_strip('export FFLAGS_GENERATE="$FFLAGS {0} "\n'.format(" ".join(genflags)))
            self._write_strip('export CXXFLAGS_GENERATE="$CXXFLAGS {0} "\n'.format(" ".join(genflags)))

            self._write_strip('export CFLAGS_USE="$CFLAGS {0} "\n'.format(" ".join(useflags)))
            self._write_strip('export FCFLAGS_USE="$FCFLAGS {0} "\n'.format(" ".join(useflags)))
            self._write_strip('export FFLAGS_USE="$FFLAGS {0} "\n'.format(" ".join(useflags)))
            self._write_strip('export CXXFLAGS_USE="$CXXFLAGS {0} "\n'.format(" ".join(useflags)))

    def write_check(self):
        """Write check section to spec file"""
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            self._write_strip("export LANG=C")
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
            self._write_strip("\n")

    def write_make_install(self):
        """Write install section to spec file for make builds"""
        self._write_strip("%install")
        # time.time() returns a float, but we only need second-precision
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")

        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self._write_strip("%make_install32 " + self.extra_make_install)
            self._write_strip("if [ -d  %{buildroot}/usr/lib32/pkgconfig ]")
            self._write_strip("then")
            self._write_strip("    pushd %{buildroot}/usr/lib32/pkgconfig")
            self._write_strip("    for i in *.pc ; do ln -s $i 32$i ; done")
            self._write_strip("    popd")
            self._write_strip("fi")
            self._write_strip("popd")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)

        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2/")
            self._write_strip("%s %s\n" % (self.install_macro, self.extra_make_install))
            self._write_strip("popd")

        self._write_strip("%s %s\n" % (self.install_macro, self.extra_make_install))

        if self.subdir:
            self._write_strip("popd")

        self.write_find_lang()

    def write_make_install_append(self):
        """write out any custom supplied commands at the very end of the %install section"""
        if self.make_install_append and self.make_install_append[0]:
            self._write_strip("## make_install_append content")
            for line in self.make_install_append:
                self._write_strip("{}\n".format(line))
            self._write_strip("## make_install_append end")

    def write_source_installs(self):
        """write out installs from SourceX lines"""
        if len(self.sources["unit"]) != 0:
            self._write_strip("mkdir -p %{buildroot}/usr/lib/systemd/system")
            for unit in self.sources["unit"]:
                self._write_strip("install -m 0644 %{{SOURCE{0}}} %{{buildroot}}/usr/lib/systemd/system/{1}"
                                  .format(self.source_index[unit], unit))
        if len(self.sources["tmpfile"]) != 0:
            self._write_strip("mkdir -p %{buildroot}/usr/lib/tmpfiles.d")
            self._write_strip("install -m 0644 %{{SOURCE{0}}} %{{buildroot}}/usr/lib/tmpfiles.d/{1}.conf"
                              .format(self.source_index[self.sources["tmpfile"][0]], self.name))

    def write_cmake_install(self):
        """Write install section to spec file for cmake builds"""
        self._write_strip("%install")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")

        if config.config_opts['32bit']:
            self._write_strip("pushd clr-build32")
            self._write_strip("%make_install32 " + self.extra_make_install)
            self._write_strip("if [ -d  %{buildroot}/usr/lib32/pkgconfig ]")
            self._write_strip("then")
            self._write_strip("    pushd %{buildroot}/usr/lib32/pkgconfig")
            self._write_strip("    for i in *.pc ; do ln -s $i 32$i ; done")
            self._write_strip("    popd")
            self._write_strip("fi")
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("mkdir -p %{buildroot}/usr/lib64/haswell/avx512_1")
            self._write_strip("pushd clr-build-avx2")
            self._write_strip("%s %s || :\n" % (self.install_macro, self.extra_make_install))
            self._write_strip("mv %{buildroot}/usr/lib64/*so* %{buildroot}/usr/lib64/haswell/ || :")
            self._write_strip("popd")
            self._write_strip("rm -f %{buildroot}/usr/bin/*")

        self._write_strip("pushd clr-build")
        self._write_strip("%s %s\n" % (self.install_macro, self.extra_make_install))
        self._write_strip("popd")
        self.write_find_lang()

    @staticmethod
    def get_profile_generate_flags():
        """
        Return profile generate flags if proper configuration is set

        If config.profile_payload is non-empty, returns
                'CFLAGS="${CFLAGS_GENERATE}" '
                'CXXFLAGS="${CXXFLAGS_GENERATE}" '
                'FFLAGS="${FFLAGS_GENERATE}" '
                'FCFLAGS="${FCFLAGS_GENERATE}" '

        otherwise an empty string is returned
        """
        if config.profile_payload and config.profile_payload[0]:
            return 'CFLAGS="${CFLAGS_GENERATE}" '     \
                   'CXXFLAGS="${CXXFLAGS_GENERATE}" ' \
                   'FFLAGS="${FFLAGS_GENERATE}" '     \
                   'FCFLAGS="${FCFLAGS_GENERATE}" '
        return ""

    @staticmethod
    def get_profile_use_flags():
        """
        Return profile generate flags if proper configuration is set

        If config.profile_payload is non-empty, returns
                'CFLAGS="${CFLAGS_USE}" '
                'CXXFLAGS="${CXXFLAGS_USE}" '
                'FFLAGS="${FFLAGS_USE}" '
                'FCFLAGS="${FCFLAGS_USE}" '

        otherwise an empty string is returned
        """
        if config.profile_payload and config.profile_payload[0]:
            return 'CFLAGS="${CFLAGS_USE}" '     \
                   'CXXFLAGS="${CXXFLAGS_USE}" ' \
                   'FFLAGS="${FFLAGS_USE}" '     \
                   'FCFLAGS="${FCFLAGS_USE}" '
        return ""

    def get_systemd_units(self):
        """get systemd unit files from the files module"""
        service_file_section = "config"
        systemd_service_pattern = r"^/usr/lib/systemd/system/[^/]*\.(mount|service|socket|target)$"
        systemd_units = []

        if service_file_section not in self.packages:
            return systemd_units

        for serv_f in self.packages[service_file_section]:
            if re.search(systemd_service_pattern, serv_f) and serv_f not in self.excludes:
                systemd_units.append(serv_f)

        return systemd_units

    def write_systemd_units(self):
        """write out installs for systemd unit files"""
        units = self.get_systemd_units()
        for unit in units:
            self._write("systemctl --root=%{{buildroot}} enable {0}\n".format(os.path.basename(unit)))

    def write_configure_pattern(self):
        """Write configure build pattern to spec file"""
        if self.autoreconf:
            # Patches affecting configure.* or Makefile.*, reconf instead
            self.write_configure_ac_pattern()
            return
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()

        # Prep it for PGO
        if config.profile_payload and config.profile_payload[0]:
            if self.subdir:
                self._write_strip("pushd " + self.subdir)
            self._write_strip("{0}%configure {1} {2} {3}"
                              .format(self.get_profile_generate_flags(),
                                      self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure64))
            self.write_make_line()
            if self.subdir:
                self._write_strip("popd")
            self._write_strip("\n")

            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")

        if self.subdir:
            self._write_strip("pushd {}".format(self.subdir))
        self._write_strip("{0}%configure {1} {2} {3}"
                          .format(self.get_profile_use_flags(),
                                  self.disable_static,
                                  config.extra_configure,
                                  config.extra_configure64))
        self.write_make_line()
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("\n")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self._write_strip("export PKG_CONFIG_PATH=\"/usr/lib32/pkgconfig\"")
            self._write_strip("export CFLAGS=\"$CFLAGS -m32\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m32\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m32\"")
            self._write_strip("%configure {0} {1} {2} "
                              " --libdir=/usr/lib32 "
                              "--build=i686-generic-linux-gnu "
                              "--host=i686-generic-linux-gnu "
                              "--target=i686-clr-linux-gnu"
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2/" + self.subdir)
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=haswell\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=haswell\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=haswell\"")
            self._write_strip("%configure {0} {1} {2} "
                              " --libdir=/usr/lib64/haswell --bindir=/usr/bin/haswell "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line()
            self._write_strip("popd")

        self.write_check()
        self.write_make_install()

    def write_configure_ac_pattern(self):
        """Write build pattern for configure.ac style build"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        # Prep it for PGO
        if config.profile_payload and config.profile_payload[0]:
            if self.subdir:
                self._write_strip("pushd " + self.subdir)
            self._write_strip("{0}%reconfigure {1} {2} {3}"
                              .format(self.get_profile_generate_flags(),
                                      self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure64))
            self.write_make_line()
            if self.subdir:
                self._write_strip("popd")
            self._write_strip("\n")

            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("{0}%reconfigure {1} {2} {3}"
                          .format(self.get_profile_use_flags(),
                                  self.disable_static,
                                  config.extra_configure,
                                  config.extra_configure64))
        self.write_make_line()
        if self.subdir:
            self._write_strip("popd")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self._write_strip("export PKG_CONFIG_PATH=\"/usr/lib32/pkgconfig\"")
            self._write_strip("export CFLAGS=\"$CFLAGS -m32\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m32\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m32\"")
            self._write_strip("%reconfigure {0} {1} {2} "
                              "--libdir=/usr/lib32 "
                              "--build=i686-generic-linux-gnu "
                              "--host=i686-generic-linux-gnu "
                              "--target=i686-clr-linux-gnu"
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2/" + self.subdir)
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=haswell\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=haswell\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=haswell\"")
            self._write_strip("%reconfigure {0} {1} {2} "
                              " --libdir=/usr/lib64/haswell --bindir=/usr/bin/haswell "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line()
            self._write_strip("popd")

        self._write_strip("\n")
        self.write_check()
        self.write_make_install()

    def write_make_pattern(self):
        """Write build pattern for make"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self.write_make_line()
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("\n")
        self.write_check()
        self.write_make_install()

    def write_autogen_pattern(self):
        """Write build pattern for autogen packages"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        if config.profile_payload and config.profile_payload[0]:
            self._write_strip("{0}%autogen {1} {2} {3}"
                              .format(self.get_profile_generate_flags(),
                                      self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure64))
            self.write_make_line()
            self._write_strip("\n")

            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")

        self._write_strip("{0}%autogen {1} {2} {3}"
                          .format(self.get_profile_use_flags(),
                                  self.disable_static,
                                  config.extra_configure,
                                  config.extra_configure64))
        self.write_make_line()
        self._write_strip("\n")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self._write_strip('export PKG_CONFIG_PATH="/usr/lib32/pkgconfig"')
            self._write_strip('export CFLAGS="$CFLAGS -m32"')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -m32"')
            self._write_strip('export LDFLAGS="$LDFLAGS -m32"')
            self._write_strip("%autogen {0} {1} {2} "
                              "--libdir=/usr/lib32 "
                              "--build=i686-generic-linux-gnu "
                              "--host=i686-generic-linux-gnu "
                              "--target=i686-clr-linux-gnu"
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line()
            self._write_strip("popd")
        self.write_check()
        self.write_make_install()

    def write_distutils_pattern(self):
        """Write build pattern for python packages using distutils"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip("python2 setup.py build -b py2 " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self._write_strip("python2 -tt setup.py build -b py2 install --root=%{buildroot}")
        self.write_find_lang()

    def write_distutils3_pattern(self):
        """Write build pattern for python packages using distutils3"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip("python3 setup.py build -b py3 " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self._write_strip("python3 -tt setup.py build -b py3 install --root=%{buildroot}")
        self._write_strip("echo ----[ mark ]----")
        self._write_strip("cat %{buildroot}/usr/lib/python3*/site-packages/*/requires.txt || :")
        self._write_strip("echo ----[ mark ]----")
        self.write_find_lang()

    def write_distutils23_pattern(self):
        """Write build pattern for python packages using distutils2 and 32 and 3"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip("python2 setup.py build -b py2 " + config.extra_configure)
        self._write_strip("python3 setup.py build -b py3 " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)

        self._write_strip("%install")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")
        self._write_strip("python2 -tt setup.py build -b py2 install --root=%{buildroot} --force")
        self._write_strip("python3 -tt setup.py build -b py3 install --root=%{buildroot} --force")
        self._write_strip("echo ----[ mark ]----")
        self._write_strip("cat %{buildroot}/usr/lib/python3*/site-packages/*/requires.txt || :")
        self._write_strip("echo ----[ mark ]----")
        self.write_find_lang()

    def write_R_pattern(self):
        """Write build pattern for R packages"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self._write_strip("\n")

        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("export LANG=C")
        self._write_strip('export CFLAGS="$CFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip('export FCFLAGS="$CFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip('export FFLAGS="$CFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip('export CXXFLAGS="$CXXFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip("export AR=gcc-ar\n")
        self._write_strip("export RANLIB=gcc-ranlib\n")
        self._write_strip('export LDFLAGS="$LDFLAGS  -Wl,-z -Wl,relro"\n')

        self._write_strip("mkdir -p %{buildroot}/usr/lib64/R/library")
        self._write_strip("\n")
        self._write_strip("mkdir -p ~/.R")
        self._write_strip("mkdir -p ~/.stash")

        self._write_strip("echo \"CFLAGS = $CFLAGS -march=haswell -ftree-vectorize \" > ~/.R/Makevars")
        self._write_strip("echo \"FFLAGS = $FFLAGS -march=haswell -ftree-vectorize \" >> ~/.R/Makevars")
        self._write_strip("echo \"CXXFLAGS = $CXXFLAGS -march=haswell -ftree-vectorize \" >> ~/.R/Makevars")

        self._write_strip("R CMD INSTALL "
                          "--install-tests "
                          "--built-timestamp=${SOURCE_DATE_EPOCH} "
                          "--build  -l "
                          "%{buildroot}/usr/lib64/R/library " + self.rawname)
        self._write_strip("for i in `find %{buildroot}/usr/lib64/R/ -name \"*.so\"`; do mv $i $i.avx2 ; mv $i.avx2 ~/.stash/; done\n")

        self._write_strip("echo \"CFLAGS = $CFLAGS -ftree-vectorize \" > ~/.R/Makevars")
        self._write_strip("echo \"FFLAGS = $FFLAGS -ftree-vectorize \" >> ~/.R/Makevars")
        self._write_strip("echo \"CXXFLAGS = $CXXFLAGS -ftree-vectorize \" >> ~/.R/Makevars")

        self._write_strip("R CMD INSTALL "
                          "--preclean "
                          "--install-tests "
                          "--built-timestamp=${SOURCE_DATE_EPOCH} "
                          "--build  -l "
                          "%{buildroot}/usr/lib64/R/library " + self.rawname)
        self._write_strip("cp ~/.stash/* %{buildroot}/usr/lib64/R/library/*/libs/ || :")

        self._write_strip("%{__rm} -rf %{buildroot}%{_datadir}/R/library/R.css")
        self.write_find_lang()
        self.write_check()

    def write_ruby_pattern(self):
        """Write build pattern for ruby packages"""
        self.write_prep(ruby_pattern=True)
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("export LANG=C")
        self._write_strip("gem build {}.gemspec".format(self.name))
        self._write_strip("\n")

        self._write_strip("%install")
        self._write_strip("%global gem_dir $(ruby -e'puts Gem.default_dir')")
        self._write_strip("gem install -V \\")
        self._write_strip("  --local \\")
        self._write_strip("  --force \\")
        self._write_strip("  --install-dir .%{gem_dir} \\")
        self._write_strip("  --bindir .%{_bindir} \\")
        self._write_strip(" {}.gem".format(self.tarball_prefix))
        self._write_strip("\n")

        self._write_strip("mkdir -p %{buildroot}%{gem_dir}")
        self._write_strip("cp -pa .%{gem_dir}/* \\")
        self._write_strip("        %{buildroot}%{gem_dir}")
        self._write_strip("\n")

        self._write_strip("if [ -d .%{_bindir} ]; then")
        self._write_strip("    mkdir -p %{buildroot}%{_bindir}")
        self._write_strip("    cp -pa .%{_bindir}/* \\")
        self._write_strip("        %{buildroot}%{_bindir}/")
        self._write_strip("fi")
        self._write_strip("\n")
        self.write_find_lang()
        self.write_check()

    def write_cmake_pattern(self):
        """Write cmake pattern to spec file"""
        self.subdir = "clr-build"
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self._write_strip("mkdir clr-build")
        self._write_strip("pushd clr-build")
        self.write_variables()
        self._write_strip("cmake .. -G \"Unix Makefiles\" "
                          "-DCMAKE_INSTALL_PREFIX=/usr -DBUILD_SHARED_LIBS:BOOL=ON "
                          "-DLIB_INSTALL_DIR:PATH=/usr/lib64 "
                          "-DCMAKE_AR=/usr/bin/gcc-ar "
                          "-DLIB_SUFFIX=64 "
                          "-DCMAKE_BUILD_TYPE=RelWithDebInfo "
                          "-DCMAKE_RANLIB=/usr/bin/gcc-ranlib " + self.extra_cmake)

        # Prep it for PGO
        if config.profile_payload and config.profile_payload[0]:
            self._write_strip("{0}".format(self.get_profile_generate_flags()))
            self.write_make_line()
            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")
            self._write_strip("{0}".format(self.get_profile_use_flags()))

        self._write_strip("make VERBOSE=1 {}{}".format(config.parallel_build, self.extra_make))
        self._write_strip("popd")

        if config.config_opts['32bit']:
            self._write_strip("mkdir clr-build32")
            self._write_strip("pushd clr-build32")
            self.write_variables()
            self._write_strip('export PKG_CONFIG_PATH="/usr/lib32/pkgconfig"')
            self._write_strip('export CFLAGS="$CFLAGS -m32"')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -m32"')
            self._write_strip('cmake .. -G "Unix Makefiles" '
                              "-DCMAKE_INSTALL_PREFIX=/usr -DBUILD_SHARED_LIBS:BOOL=ON "
                              "-DLIB_INSTALL_DIR:PATH=/usr/lib32 "
                              "-DCMAKE_AR=/usr/bin/gcc-ar "
                              "-DLIB_SUFFIX=32 "
                              "-DCMAKE_RANLIB=/usr/bin/gcc-ranlib " + self.extra_cmake)
            self._write_strip("make VERBOSE=1 {}{}".format(config.parallel_build, self.extra_make))
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("mkdir clr-build-avx2")
            self._write_strip("pushd clr-build-avx2")
            saved_avx2flags = self.need_avx2_flags
            self.need_avx2_flags = True
            self.write_variables()
            self.need_avx2_flags = saved_avx2flags
            self._write_strip('export CFLAGS="$CFLAGS -march=haswell"')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -march=haswell"')
            self._write_strip('cmake .. -G "Unix Makefiles" '
                              "-DCMAKE_INSTALL_PREFIX=/usr -DBUILD_SHARED_LIBS:BOOL=ON "
                              "-DLIB_INSTALL_DIR:PATH=/usr/lib/haswell "
                              "-DCMAKE_AR=/usr/bin/gcc-ar "
                              "-DCMAKE_RANLIB=/usr/bin/gcc-ranlib " + self.extra_cmake)
            self._write_strip("make VERBOSE=1 {}{} || :".format(config.parallel_build, self.extra_make))
            self._write_strip("popd")

        self._write_strip("\n")
        self.write_check()
        self.write_cmake_install()

    def write_cargo_pattern(self):
        """Write cargo build pattern to spec file"""
        self.write_prep()
        src_dir = "/usr/share/rust/src/{0}-{1}".format(self.name, self.version)
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("mkdir .cargo")
        self._write("echo \"[source.crates-io]\nreplace-with = 'vendored-sources'\n[source.vendored-sources]\ndirectory = '{}'\" > .cargo/config\n".format(os.path.dirname(src_dir)))
        self._write_strip('echo \'{"files":{},"package":""}\' > .cargo-checksum.json')
        # Don't let cargo get outside
        self._write_strip("export http_proxy=http://127.0.0.1:9/")
        self._write_strip("export https_proxy=http://127.0.0.1:9/")
        self._write_strip("export no_proxy=localhost,127.0.0.1,0.0.0.0")
        self._write_strip("cargo build --release")
        self._write_strip("\n")
        self._write_strip("%install")
        if self.cargo_bin:
            self._write_strip("cargo install --frozen --root /")
        self._write_strip("cargo clean")
        self._write_strip("install -d -p %{buildroot}" + src_dir)
        self._write_strip("cp -a . %{buildroot}" + src_dir)
        self.write_make_install_append()

    def write_cpan_pattern(self):
        """Write cpan build pattern to spec file"""
        self.write_prep()
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("export LANG=C")
        self._write_strip("if test -f Makefile.PL; then")
        self._write_strip("%{__perl} Makefile.PL")
        self.write_make_line()
        self._write_strip("else")
        self._write_strip("%{__perl} Build.PL")
        self._write_strip("./Build")
        self._write_strip("fi")
        self._write_strip("\n")
        self.write_check()
        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self._write_strip("if test -f Makefile.PL; then")
        self._write_strip("make pure_install PERL_INSTALL_ROOT=%{buildroot}")
        self._write_strip("else")
        self._write_strip("./Build install --installdirs=site --destdir=%{buildroot}")
        self._write_strip("fi")
        self._write_strip("find %{buildroot} -type f -name .packlist -exec rm -f {} ';'")
        self._write_strip("find %{buildroot} -depth -type d -exec rmdir {} 2>/dev/null ';'")
        self._write_strip("find %{buildroot} -type f -name '*.bs' -empty -exec rm -f {} ';'")
        self._write_strip("%{_fixperms} %{buildroot}/*")
        self.write_find_lang()

    def write_scons_pattern(self):
        """Write scons build pattern to spec file"""
        self.write_prep()
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("export LANG=C")
        self.write_variables()
        self._write_strip("scons{} {}".format(config.parallel_build, config.extra_configure))
        self._write_strip("\n")
        self._write_strip("%install")
        self._write_strip("scons install " + self.extra_make_install)

    def write_golang_pattern(self):
        """Write build pattern for go packages"""
        self.write_prep()
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("export LANG=C")
        self._write_strip("export GOPATH=\"$PWD\"")
        self._write_strip("go build")
        self._write_strip("\n")
        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self._write_strip("\n")

    def write_maven_pattern(self):
        """Write maven build pattern to spec file"""
        mvn = self.extra_make_install if self.extra_make_install else self.tarball_prefix

        self.write_prep()
        self._write_strip("%build")
        self.write_proxy_exports()
        self._write_strip("python3 /usr/share/java-utils/mvn_build.py " + self.extra_make)
        self._write_strip("\n")
        self._write_strip("%install")
        self._write_strip("xmvn-install  -R .xmvn-reactor -n {} -d %{{buildroot}}"
                          .format(mvn))

    def write_meson_pattern(self):
        """Write meson build pattern to spec file"""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip('CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" meson --prefix /usr --buildtype=plain {0} builddir'.format(config.extra_configure))
        self._write_strip("ninja -v -C builddir")
        self._write_strip("\n")
        self._write_strip("%install")
        self._write_strip("DESTDIR=%{buildroot} ninja -C builddir install")
        self.write_find_lang()

    def write_find_lang(self):
        for lang in self.locales:
            self._write("%find_lang {}\n".format(lang))

    def apply_patches(self):
        """Write patch list to spec file"""
        counter = 1
        for p in self.patches:
            name = p.split(None, 1)[0]
            if name == p:
                options = "-p1"
            else:
                options = p.split(None, 1)[1]
            if not p.split()[0].endswith(".nopatch"):
                self._write("%patch{} {}\n".format(counter, options))
            counter = counter + 1

    def _write(self, string):
        self.specfile.write(string)

    def _write_strip(self, string):
        self.specfile.write_strip(string)

    def quote_filename(self, filename):
        """
        Quotes the filename, if necessary. Identifies and skips any RPM directive prefix.
        """
        # Characters that require quoting -- only those with special
        # meaning in specfiles
        special_chars = set(" \t")
        # Build up the output as a string
        quoted = ''
        # Capture any directive prefix separately from actual filename
        #                          (1                   )(3 )
        directive_re = re.compile("(%\w+(\([^\)]*\))?\s+)(.*)")
        parts = directive_re.match(filename)
        if parts:
            # Add prefix to the output
            quoted += parts.group(1)
            # Set the filename to the remaining portion
            filename = parts.group(3)

        # Now check for special characters
        if any(c in filename for c in special_chars):
            # Quote the filename
            quoted += '"{}"'.format(filename)
        else:
            # Add the filename as-is
            quoted += filename
        return quoted
