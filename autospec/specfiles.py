#!/usr/bin/python3
#
# specfile.py - part of autospec
# Copyright (C) 2016 Intel Corporation
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Write spec file
#

import os
import re
import time
import types
from collections import OrderedDict

import buildreq
import config
from util import _file_write
from util import open_auto


class Specfile(object):
    """Holds data and methods needed to write the spec file."""

    def __init__(self, url, version, name, release):
        """Add default information for specfile template."""
        self.url = url
        self.version = version
        self.name = name
        self.release = release
        self.keepstatic = False
        self.urlban = ""
        self.no_autostart = False
        self.specfile = None
        self.sources = {"unit": [], "gcov": [], "tmpfile": [], "archive": []}
        self.source_index = {}
        self.default_sum = ""
        self.licenses = []
        self.license_files = []
        self.packages = OrderedDict()
        self.requires = set()
        self.buildreqs = []
        self.patches = []
        self.default_desc = ""
        self.locales = []
        self.default_pattern = ""
        self.autoreconf = False
        self.set_gopath = True
        self.extra_make = ""
        self.extra32_make = ""
        self.extra_make_install = ""
        self.extra_make32_install = ""
        self.tarball_prefix = ""
        self.gcov_file = ""
        self.rawname = ""
        self.golibpath = ""
        self.archive_details = {}
        self.need_avx2_flags = False
        self.need_avx512_flags = False
        self.tests_config = ""
        self.subdir = ""
        self.install_macro = "%make_install"
        self.disable_static = "--disable-static"
        self.extra_cmake = ""
        self.cmake_srcdir = ".."
        self.prep_prepend = []
        self.build_prepend = []
        self.make_prepend = []
        self.install_prepend = []
        self.install_append = []
        self.excludes = []
        self.custom_extras = {}
        self.keyid = ""
        self.email = ""
        self.cargo_bin = False

    def write_spec(self, path):
        """Write spec file."""
        self.specfile = open_auto("{}/{}.spec".format(path, self.name), "w")
        self.specfile.write_strip = types.MethodType(_file_write, self.specfile)

        # spec file comment header
        self.write_comment_header()

        if self.keepstatic:
            self._write("%define keepstatic 1\n")

        # general package header
        self.write_nvr()
        self.write_sources()
        self.write_summary()
        self.write_license()

        self.write_main_subpackage_requires()
        self.write_buildreq()
        self.write_strip_command()
        self.write_patch_header()

        # main package extra content
        self.write_description()
        self.write_files_header()

        # build instructions
        self.write_buildpattern()

        # scriplets
        self.write_scriplets()

        # %files
        self.write_files()
        self.write_lang_files()

        self.specfile.close()

    def write_comment_header(self):
        """Write comment header to spec file."""
        self._write("#\n")
        self._write("# This file is auto-generated. DO NOT EDIT\n")
        self._write("# Generated by: autospec.py\n")
        self._write("#\n")

        # if package was verified, write public key information
        if self.keyid:
            sig_msg = "# Source0 file verified with key 0x{}".format(self.keyid)
            if self.email:
                sig_msg += " ({})".format(self.email)

            self._write_strip(sig_msg)
            self._write_strip("#")

    def write_nvr(self):
        """Write name, version, and release information."""
        if self.urlban:
            self.url = re.sub(self.urlban, "localhost", self.url)
        self._write("Name     : {}\n".format(self.name))
        self._write("Version  : {}\n".format(self.version))
        self._write("Release  : {}\n".format(str(self.release)))
        self._write("URL      : {}\n".format(self.url))
        self._write("Source0  : {}\n".format(self.url))

    def write_sources(self):
        """Append additional source files.

        Append systemd unit files, gcov, and additional source tarballs are the currently supported file types.
        """
        for count, source in enumerate(
                sorted(self.sources["unit"] + self.sources["archive"] + self.sources["tmpfile"] + self.sources["gcov"])):
            self.source_index[source] = count + 1
            if self.urlban:
                source = re.sub(self.urlban, "localhost", source)
            self._write("Source{0}  : {1}\n".format(count + 1, source))

        # if package is verified, include the signature in the source tarball
        if self.keyid and config.signature:
            self._write_strip("Source99 : {}".format(config.signature))

    def write_summary(self):
        """Write package summary to spec file."""
        if len(self.default_sum.strip()) < 1:
            self.default_sum = "No summary provided"
        self._write("Summary  : {}\n".format(self.default_sum.strip()))
        self._write("Group    : Development/Tools\n")

    def write_license(self):
        """Write license information to spec file."""
        self._write("License  : {}\n".format(" ".join(sorted(self.licenses))))

    def write_main_subpackage_requires(self):
        """Write subpackage build requirements."""
        for pkg in sorted(self.packages):
            if pkg == "autostart" and self.no_autostart:
                continue
            if pkg.startswith("extras-"):
                continue
            if pkg in ["ignore", "main", "dev", "active-units", "extras",
                       "lib32", "dev32", "legacypython", "doc", "abi", "staticdev",
                       "staticdev32"]:
                continue
            # honor requires_ban for manual overrides
            if "{}-{}".format(self.name, pkg) in buildreq.banned_requires:
                continue
            self._write("Requires: {}-{} = %{{version}}-%{{release}}\n".format(self.name, pkg))

        for pkg in sorted(self.requires):
            self._write("Requires: {}\n".format(pkg))

    def write_buildreq(self):
        """Write build requirements."""
        for req in sorted(self.buildreqs):
            self._write("BuildRequires : {}\n".format(req))

    def write_strip_command(self):
        """Write commands to prevent stripping binary if requested."""
        if config.config_opts['nostrip']:
            self._write("# Suppress stripping binaries\n")
            self._write("%define __strip /bin/true\n%define debug_package %{nil}\n")

    def write_patch_header(self):
        """Write patch list header."""
        for count, patch in enumerate(self.patches):
            self._write("Patch{0}: {1}\n".format(count + 1, patch.split()[0]))

    def write_description(self):
        """Write package description."""
        self._write("\n%description\n{}\n".format(self.default_desc.strip()))

    def write_files_header(self):
        """Write file headers to spec file."""
        groups = {}
        groups["dev"] = "Development"
        groups["bin"] = "Binaries"
        groups["lib"] = "Libraries"
        groups["doc"] = "Documentation"
        groups["data"] = "Data"
        groups["services"] = "Systemd services"

        deps = {}
        deps["dev"] = ["lib", "bin", "data"]
        deps["doc"] = ["man"]
        deps["dev32"] = ["lib32", "bin", "data", "dev"]
        deps["bin"] = ["data", "libexec", "config", "setuid", "attr", "license", "services"]
        deps["lib"] = ["data", "libexec", "license"]
        deps["libexec"] = ["config", "license"]
        deps["lib32"] = ["data", "license"]
        deps["python"] = ["python3"]
        if config.config_opts['dev_requires_extras']:
            deps["dev"].append("extras")
        for k, v in self.custom_extras.items():
            if "requires" in v:
                deps[k] = v['requires']

        # migration workaround; if we have a python3 or legacypython package
        # we add an artificial python package

        if ("python3" in self.packages or "legacypython" in self.packages) and ("python" not in self.packages):
            self.packages["python"] = set()

        provides = {}
        provides["dev"] = ["devel"]

        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main"]:
                continue

            self._write("\n%package {}\n".format(pkg))
            self._write("Summary: {} components for the {} package.\n"
                        .format(pkg, self.name))
            if pkg in groups:
                self._write("Group: {}\n".format(groups[pkg]))
            else:
                self._write("Group: Default\n")

            for dep in deps.get(pkg, []):
                if dep in self.packages:
                    self._write("Requires: {}-{} = %{{version}}-%{{release}}\n".format(self.name, dep))

            for prov in provides.get(pkg, []):
                self._write("Provides: {}-{} = %{{version}}-%{{release}}\n".format(self.name, prov))

            if pkg == "python":
                if self.name != self.name.lower():
                    self._write("Provides: {}-python\n".format(self.name.lower()))

            if pkg == "dev":
                self._write("Requires: {} = %{{version}}-%{{release}}\n".format(self.name))

            if pkg == "staticdev":
                self._write("Requires: {}-dev = %{{version}}-%{{release}}\n".format(self.name))

            if pkg == "staticdev32":
                self._write("Requires: {}-dev = %{{version}}-%{{release}}\n".format(self.name))

            if pkg == "python3":
                self._write("Requires: python3-core\n")

            if pkg == "legacypython":
                self._write("Requires: python-core\n")

            self._write("\n%description {}\n".format(pkg))
            self._write("{} components for the {} package.\n".format(pkg, self.name))
            self._write("\n")

    def write_buildpattern(self):
        """Write build pattern to spec file.

        Currently depends on buildpattern.py due to pattern-matched methods.
        """
        self._write_strip("\n")
        pattern_method = getattr(self, 'write_{}_pattern'.format(self.default_pattern))
        if pattern_method:
            pattern_method()

        self.write_source_installs()
        self.write_install_append()
        # self.write_systemd_units()

    def write_scriplets(self):
        """Write post and pre scripts to spec file."""
        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main", "locales"]:
                continue
            for script in ["post", "pre"]:
                content = config.read_conf_file("{}.{}".format(script, pkg))
                if content:
                    self._write("\n%{0} {1}\n".format(script, pkg))
                    content = ['{}\n'.format(l) for l in content]
                    self.specfile.writelines(content)

    def write_files(self):
        """Write %files section to spec file."""
        self._write("\n%files\n")
        self._write("%defattr(-,root,root,-)\n")
        if "main" in self.packages:
            for filename in sorted(self.packages["main"]):
                self._write("{}\n".format(self.quote_filename(filename)))

        for pkg in sorted(self.packages):
            if pkg in ["ignore", "main", "locales"]:
                continue

            self._write("\n%files {}\n".format(pkg))
            if pkg in ["doc", "license", "man"]:
                self._write("%defattr(0644,root,root,0755)\n")
            else:
                self._write("%defattr(-,root,root,-)\n")
            for filename in sorted(self.packages[pkg]):
                self._write("{}\n".format(self.quote_filename(filename)))

    def write_lang_files(self):
        """Write lang files to spec."""
        if not self.locales:
            return

        self._write("\n%files locales")
        for lang in self.locales:
            self._write(" -f {}.lang".format(lang))

        self._write("\n%defattr(-,root,root,-)\n\n")

    def write_lang_c(self, export_epoch=False):
        """Write C language pattern."""
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("export LANG=C.UTF-8")
        if export_epoch:
            # time.time() returns a float, but we only need second-precision
            self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        if config.config_opts['asneeded']:
            self._write_strip("unset LD_AS_NEEDED\n")

    def write_proxy_exports(self):
        """Write proxy exports to localhost to block build/check calls to internet."""
        self._write_strip("export http_proxy=http://127.0.0.1:9/")
        self._write_strip("export https_proxy=http://127.0.0.1:9/")
        self._write_strip("export no_proxy=localhost,127.0.0.1,0.0.0.0")

    def write_make_line(self, build32=False):
        """Write make line to spec file."""
        if self.make_prepend:
            self._write_strip("## make_prepend content")
            for line in self.make_prepend:
                self._write_strip("{}\n".format(line))
            self._write_strip("## make_prepend end")
        if build32:
            self._write_strip("make {}{}{}".format(config.parallel_build, self.extra_make, self.extra32_make))
        else:
            self._write_strip("make {}{}".format(config.parallel_build, self.extra_make))

    def write_prep(self, ruby_pattern=False):
        """Write prep section to spec file."""
        self._write_strip("%prep")
        self.write_prep_prepend()
        if ruby_pattern:
            self._write_strip("gem unpack %{SOURCE0}")
            self._write_strip("%setup -q -D -T -n " + self.tarball_prefix)
            self._write_strip("gem spec %{{SOURCE0}} -l --ruby > {}.gemspec".format(self.name))
        else:
            if self.default_pattern == 'R':
                self._write_strip("%setup -q -c -n " + self.tarball_prefix)
            else:
                self._write_strip("%setup -q -n " + self.tarball_prefix)
                for archive in self.sources["archive"]:
                    self._write_strip("cd ..")
                    self._write_strip("%setup -q -T -D -n {0} -b {1}"
                                      .format(self.tarball_prefix,
                                              self.source_index[archive]))

        for archive, destination in zip(self.sources["archive"], self.sources["destination"]):
            if destination.startswith(':'):
                continue
            if self.archive_details[archive + "prefix"] == self.tarball_prefix:
                print("Archive {} already unpacked in {}; ignoring destination"
                      .format(archive, self.tarball_prefix))
            else:
                self._write_strip("mkdir -p {}"
                                  .format(destination))
                self._write_strip("cp -r %{{_topdir}}/BUILD/{0}/* %{{_topdir}}/BUILD/{1}/{2}"
                                  .format(self.archive_details[archive + "prefix"],
                                          self.tarball_prefix,
                                          destination))
        self.apply_patches()
        if self.default_pattern != 'cmake':
            if config.config_opts['32bit']:
                self._write_strip("pushd ..")
                self._write_strip("cp -a {} build32".format(self.tarball_prefix))
                self._write_strip("popd")
            if config.config_opts['use_avx2']:
                self._write_strip("pushd ..")
                self._write_strip("cp -a {} buildavx2".format(self.tarball_prefix))
                self._write_strip("popd")
            if config.config_opts['use_avx512']:
                self._write_strip("pushd ..")
                self._write_strip("cp -a {} buildavx512".format(self.tarball_prefix))
                self._write_strip("popd")
        self._write_strip("\n")

    def write_32bit_exports(self):
        """Write 32bit only env exports."""
        self._write_strip('export PKG_CONFIG_PATH="/usr/lib32/pkgconfig"')
        self._write_strip('export ASFLAGS="${ASFLAGS}${ASFLAGS:+ }--32"')
        self._write_strip('export CFLAGS="${CFLAGS}${CFLAGS:+ }-m32"')
        self._write_strip('export CXXFLAGS="${CXXFLAGS}${CXXFLAGS:+ }-m32"')
        self._write_strip('export LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-m32"')

    def write_variables(self):
        """Write variable exports to spec file."""
        flags = []
        arch = os.uname()[4]

        # Clear ships with a patch in GCC that allows ignoring the -Werror
        # compilation flag if this environment variable is set.  -Werror
        # is a useful flag for the upstream package maintainers, but is
        # a source of headaches for downstream users.
        self._write_strip("export GCC_IGNORE_WERROR=1\n")

        if config.config_opts['use_clang']:
            self._write_strip("export CC=clang\n")
            self._write_strip("export CXX=clang++\n")
            self._write_strip("export LD=ld.gold\n")
            lto = "-flto"
        else:
            lto = "-flto=4"

        if config.config_opts['optimize_size']:
            if config.config_opts['use_clang']:
                flags.extend(["-Os", "-ffunction-sections", "-fdata-sections"])
            else:
                flags.extend(["-Os", "-ffunction-sections", "-fdata-sections", "-fno-semantic-interposition"])
        if config.config_opts['security_sensitive']:
            flags.append("-fstack-protector-strong")
            if arch == 'x86_64':
                flags.append("-mzero-caller-saved-regs=used")
        if self.need_avx2_flags:
            flags.extend(["-O3", "-march=haswell"])
        if self.need_avx512_flags:
            flags.extend(["-O3", "-march=skylake-avx512"])
        if config.config_opts['insecure_build']:
            self._write_strip('export CFLAGS="-O3 -g -fopt-info-vec "\n')
            self._write_strip("unset LDFLAGS\n")
        if config.config_opts['conservative_flags']:
            self._write_strip('export CFLAGS="-O2 -g -Wp,-D_FORTIFY_SOURCE=2 '
                              "-fexceptions -fstack-protector "
                              "--param=ssp-buffer-size=32 -Wformat "
                              "-Wformat-security -Wno-error "
                              "-Wl,-z,max-page-size=0x1000 "
                              '-march=westmere -mtune=haswell"\n')
            self._write_strip("export CXXFLAGS=$CFLAGS\n")
            self._write_strip("unset LDFLAGS\n")
        if config.config_opts['use_clang']:
            self._write_strip("unset LDFLAGS\n")
        if config.config_opts['funroll-loops']:
            if config.config_opts['use_clang']:
                flags.extend(["-O3"])
            else:
                flags.extend(["-O3", "-fno-semantic-interposition", "-falign-functions=32", "-fno-math-errno", "-fno-trapping-math"])
        if self.default_pattern != 'qmake':
            if config.config_opts['use_lto']:
                flags.extend(["-O3", lto, "-ffat-lto-objects"])
                if config.config_opts['use_clang']:
                    self._write_strip("export AR=llvm-ar\n")
                    self._write_strip("export RANLIB=llvm-ranlib\n")
                    self._write_strip("export NM=llvm-nm\n")
                else:
                    self._write_strip("export AR=gcc-ar\n")
                    self._write_strip("export RANLIB=gcc-ranlib\n")
                    self._write_strip("export NM=gcc-nm\n")
            else:
                flags.extend(["-fno-lto"])
        if config.config_opts['fast-math']:
            flags.extend(["-ffast-math", "-ftree-loop-vectorize"])
        if config.config_opts['pgo']:
            flags.extend(["-O3", "-fprofile-use", "-fprofile-dir=/var/tmp/pgo", "-fprofile-correction"])
        if self.gcov_file:
            flags = list(filter((lto).__ne__, flags))
            flags.extend(["-O3", "-fauto-profile=%{{SOURCE{0}}}".format(self.source_index[self.sources["gcov"][0]])])
        if flags or config.config_opts['broken_c++']:
            flags = sorted(list(set(flags)))
            self._write_strip('export CFLAGS="$CFLAGS {0} "\n'.format(" ".join(flags)))
            self._write_strip('export FCFLAGS="$CFLAGS {0} "\n'.format(" ".join(flags)))
            self._write_strip('export FFLAGS="$CFLAGS {0} "\n'.format(" ".join(flags)))
            # leave the export CXXFLAGS line open in case
            self._write('export CXXFLAGS="$CXXFLAGS {0} '.format(" ".join(flags)))
            if config.config_opts['broken_c++']:
                self._write('-std=gnu++98')
            # close the open quote from CXXFLAGS export and add newline
            self._write('"\n')

        if config.profile_payload and config.profile_payload[0] and not self.need_avx2_flags:
            genflags = []
            useflags = []
            genflags.extend(["-fprofile-generate", "-fprofile-dir=/var/tmp/pgo", "-fprofile-update=atomic"])
            useflags.extend(["-fprofile-use", "-fprofile-dir=/var/tmp/pgo", "-fprofile-correction"])

            self._write_strip('export CFLAGS_GENERATE="$CFLAGS {0} "\n'.format(" ".join(genflags)))
            self._write_strip('export FCFLAGS_GENERATE="$FCFLAGS {0} "\n'.format(" ".join(genflags)))
            self._write_strip('export FFLAGS_GENERATE="$FFLAGS {0} "\n'.format(" ".join(genflags)))
            self._write_strip('export CXXFLAGS_GENERATE="$CXXFLAGS {0} "\n'.format(" ".join(genflags)))

            self._write_strip('export CFLAGS_USE="$CFLAGS {0} "\n'.format(" ".join(useflags)))
            self._write_strip('export FCFLAGS_USE="$FCFLAGS {0} "\n'.format(" ".join(useflags)))
            self._write_strip('export FFLAGS_USE="$FFLAGS {0} "\n'.format(" ".join(useflags)))
            self._write_strip('export CXXFLAGS_USE="$CXXFLAGS {0} "\n'.format(" ".join(useflags)))

    def write_check(self):
        """Write check section to spec file."""
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            self._write_strip("export LANG=C.UTF-8")
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
            self._write_strip("\n")

    def write_make_install(self):
        """Write install section to spec file for make builds."""
        self._write_strip("%install")
        # time.time() returns a float, but we only need second-precision
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()

        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")

        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self._write_strip("%make_install32 {} {}".format(self.extra_make_install,
                                                             self.extra_make32_install))
            self._write_strip("if [ -d  %{buildroot}/usr/lib32/pkgconfig ]")
            self._write_strip("then")
            self._write_strip("    pushd %{buildroot}/usr/lib32/pkgconfig")
            self._write_strip("    for i in *.pc ; do ln -s $i 32$i ; done")
            self._write_strip("    popd")
            self._write_strip("fi")
            self._write_strip("popd")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)

        if config.config_opts['use_avx512']:
            self._write_strip("pushd ../buildavx512/")
            self._write_strip("%s_avx512 %s\n" % (self.install_macro, self.extra_make_install))
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2/")
            self._write_strip("%s_avx2 %s\n" % (self.install_macro, self.extra_make_install))
            self._write_strip("popd")

        self._write_strip("%s %s\n" % (self.install_macro, self.extra_make_install))

        if self.subdir:
            self._write_strip("popd")

        self.write_find_lang()

    def write_mvnbin_install(self):
        patterns = [
            re.compile(r"maven.org/maven2/([a-zA-Z\-\_]+)/([a-zA-Z\-\_]+)/([a-zA-Z-\_\d.]+)/[a-zA-Z-\_\d.]*\.(?:pom|jar|xml|signature)"),
            re.compile(r"maven.apache.org/maven2/([a-zA-Z\-\_]+)/([a-zA-Z\-\_]+)/([\d.]+)/[a-z-\_.\d]*\.(?:pom|jar|xml|signature)"),
            re.compile(r"maven.org/maven2/([a-zA-Z-\_.\d/]+)/([a-zA-Z-\_.\d]*)/([a-zA-Z\d\.\_\-]+)/(?:[a-zA-Z-\_.\d]*)\.(?:pom|jar|xml|signature)")]
        mvn_sources = [self.url] + sorted(self.sources["archive"])
        src_num = 0

        for src in mvn_sources:
            for pat in patterns:
                m = pat.search(src)
                if m:
                    groupid = m.group(1)
                    artifactid = m.group(2)
                    version = m.group(3)
                    src_dir = "{}/{}/{}".format(groupid, artifactid, version)

                    self._write_strip("mkdir -p %{{buildroot}}/usr/share/java/.m2/repository/{}".format(src_dir))
                    self._write_strip("cp %{{SOURCE{}}} %{{buildroot}}/usr/share/java/.m2/repository/{}".format(src_num, src_dir))
                    self._write_strip("\n")
                    break
            src_num += 1

    def write_prep_prepend(self):
        """Write out any custom supplied commands at the start of the %prep section."""
        if self.prep_prepend:
            self._write_strip("## prep_prepend content")
            for line in self.prep_prepend:
                self._write_strip("{}\n".format(line))
            self._write_strip("## prep_prepend end")

    def write_build_prepend(self):
        """Write out any custom supplied commands at the start of the %build section."""
        if self.build_prepend:
            self._write_strip("## build_prepend content")
            for line in self.build_prepend:
                self._write_strip("{}\n".format(line))
            self._write_strip("## build_prepend end")

    def write_install_prepend(self):
        """Write out any custom supplied commands at the start of the %install section."""
        if self.install_prepend:
            self._write_strip("## install_prepend content")
            for line in self.install_prepend:
                self._write_strip("{}\n".format(line))
            self._write_strip("## install_prepend end")

    def write_install_append(self):
        """Write out any custom supplied commands at the very end of the %install section."""
        if self.install_append:
            self._write_strip("## install_append content")
            for line in self.install_append:
                self._write_strip("{}\n".format(line))
            self._write_strip("## install_append end")

    def write_source_installs(self):
        """Write out installs from SourceX lines."""
        if len(self.sources["unit"]) != 0:
            self._write_strip("mkdir -p %{buildroot}/usr/lib/systemd/system")
            for unit in self.sources["unit"]:
                self._write_strip("install -m 0644 %{{SOURCE{0}}} %{{buildroot}}/usr/lib/systemd/system/{1}"
                                  .format(self.source_index[unit], unit))
        if len(self.sources["tmpfile"]) != 0:
            self._write_strip("mkdir -p %{buildroot}/usr/lib/tmpfiles.d")
            self._write_strip("install -m 0644 %{{SOURCE{0}}} %{{buildroot}}/usr/lib/tmpfiles.d/{1}.conf"
                              .format(self.source_index[self.sources["tmpfile"][0]], self.name))

    def write_cmake_install(self):
        """Write install section to spec file for cmake builds."""
        self._write_strip("%install")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()

        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)

        if config.config_opts['32bit']:
            self._write_strip("pushd clr-build32")
            self._write_strip("%make_install32 {} {}".format(self.extra_make_install,
                                                             self.extra_make32_install))
            self._write_strip("if [ -d  %{buildroot}/usr/lib32/pkgconfig ]")
            self._write_strip("then")
            self._write_strip("    pushd %{buildroot}/usr/lib32/pkgconfig")
            self._write_strip("    for i in *.pc ; do ln -s $i 32$i ; done")
            self._write_strip("    popd")
            self._write_strip("fi")
            self._write_strip("popd")

        if config.config_opts['use_avx512']:
            self._write_strip("pushd clr-build-avx512")
            self._write_strip("%s_avx512 %s || :\n" % (self.install_macro, self.extra_make_install))
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("pushd clr-build-avx2")
            self._write_strip("%s_avx2 %s || :\n" % (self.install_macro, self.extra_make_install))
            self._write_strip("popd")

        self._write_strip("pushd clr-build")
        self._write_strip("%s %s\n" % (self.install_macro, self.extra_make_install))
        self._write_strip("popd")

        if self.subdir:
            self._write_strip("popd")

        self.write_find_lang()

    @staticmethod
    def get_profile_generate_flags():
        """Return profile generate flags if proper configuration is set.

        If config.profile_payload is non-empty, returns
                'CFLAGS="${CFLAGS_GENERATE}" '
                'CXXFLAGS="${CXXFLAGS_GENERATE}" '
                'FFLAGS="${FFLAGS_GENERATE}" '
                'FCFLAGS="${FCFLAGS_GENERATE}" '

        otherwise an empty string is returned.
        """
        if config.profile_payload and config.profile_payload[0]:
            return 'CFLAGS="${CFLAGS_GENERATE}" '     \
                   'CXXFLAGS="${CXXFLAGS_GENERATE}" ' \
                   'FFLAGS="${FFLAGS_GENERATE}" '     \
                   'FCFLAGS="${FCFLAGS_GENERATE}" '
        return ""

    @staticmethod
    def get_profile_use_flags():
        """Return profile generate flags if proper configuration is set.

        If config.profile_payload is non-empty, returns
                'CFLAGS="${CFLAGS_USE}" '
                'CXXFLAGS="${CXXFLAGS_USE}" '
                'FFLAGS="${FFLAGS_USE}" '
                'FCFLAGS="${FCFLAGS_USE}" '

        otherwise an empty string is returned.
        """
        if config.profile_payload and config.profile_payload[0]:
            return 'CFLAGS="${CFLAGS_USE}" '     \
                   'CXXFLAGS="${CXXFLAGS_USE}" ' \
                   'FFLAGS="${FFLAGS_USE}" '     \
                   'FCFLAGS="${FCFLAGS_USE}" '
        return ""

    def get_systemd_units(self):
        """Get systemd unit files from the files module."""
        service_file_section = "config"
        systemd_service_pattern = r"^/usr/lib/systemd/system/[^/]*\.(mount|service|socket|target)$"
        systemd_units = []

        if service_file_section not in self.packages:
            return systemd_units

        for serv_f in self.packages[service_file_section]:
            if re.search(systemd_service_pattern, serv_f) and serv_f not in self.excludes:
                systemd_units.append(serv_f)

        return systemd_units

    def write_systemd_units(self):
        """Write out installs for systemd unit files."""
        units = self.get_systemd_units()
        for unit in units:
            self._write("systemctl --root=%{{buildroot}} enable {0}\n".format(os.path.basename(unit)))

    def write_configure_pattern(self):
        """Write configure build pattern to spec file."""
        if self.autoreconf:
            # Patches affecting configure.* or Makefile.*, reconf instead
            self.write_configure_ac_pattern()
            return
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()

        # Prep it for PGO
        if config.profile_payload and config.profile_payload[0]:
            if self.subdir:
                self._write_strip("pushd " + self.subdir)
            self._write_strip("{0}%configure {1} {2} {3}"
                              .format(self.get_profile_generate_flags(),
                                      self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure64))
            self.write_make_line()
            if self.subdir:
                self._write_strip("popd")
            self._write_strip("\n")

            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")

        if self.subdir:
            self._write_strip("pushd {}".format(self.subdir))
        self._write_strip("{0}%configure {1} {2} {3}"
                          .format(self.get_profile_use_flags(),
                                  self.disable_static,
                                  config.extra_configure,
                                  config.extra_configure64))
        self.write_make_line()
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("\n")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self.write_build_prepend()
            self.write_32bit_exports()
            self._write_strip("%configure {0} {1} {2} "
                              " --libdir=/usr/lib32 "
                              "--build=i686-generic-linux-gnu "
                              "--host=i686-generic-linux-gnu "
                              "--target=i686-clr-linux-gnu"
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line(True)
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("unset PKG_CONFIG_PATH")
            self._write_strip("pushd ../buildavx2/" + self.subdir)
            self.write_build_prepend()
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=haswell\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=haswell\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=haswell\"")
            self._write_strip("%configure {0} {1} {2} "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure_avx2))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['use_avx512']:
            self._write_strip("unset PKG_CONFIG_PATH")
            self.write_build_prepend()
            self._write_strip("pushd ../buildavx512/" + self.subdir)
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=skylake-avx512 -mprefer-vector-width=512\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=skylake-avx512 -mprefer-vector-width=512\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=skylake-avx512\"")
            self._write_strip("%configure {0} {1} {2} "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure_avx512))
            self.write_make_line()
            self._write_strip("popd")

        self.write_check()
        self.write_make_install()

    def write_configure_ac_pattern(self):
        """Write build pattern for configure.ac style build."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        # Prep it for PGO
        if config.profile_payload and config.profile_payload[0]:
            if self.subdir:
                self._write_strip("pushd " + self.subdir)
            self._write_strip("{0}%reconfigure {1} {2} {3}"
                              .format(self.get_profile_generate_flags(),
                                      self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure64))
            self.write_make_line()
            if self.subdir:
                self._write_strip("popd")
            self._write_strip("\n")

            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("{0}%reconfigure {1} {2} {3}"
                          .format(self.get_profile_use_flags(),
                                  self.disable_static,
                                  config.extra_configure,
                                  config.extra_configure64))
        self.write_make_line()
        if self.subdir:
            self._write_strip("popd")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self.write_build_prepend()
            self.write_32bit_exports()
            self._write_strip("%reconfigure {0} {1} {2} "
                              "--libdir=/usr/lib32 "
                              "--build=i686-generic-linux-gnu "
                              "--host=i686-generic-linux-gnu "
                              "--target=i686-clr-linux-gnu"
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line(True)
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("unset PKG_CONFIG_PATH")
            self._write_strip("pushd ../buildavx2/" + self.subdir)
            self.write_build_prepend()
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=haswell\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=haswell\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=haswell\"")
            self._write_strip("%reconfigure {0} {1} {2} "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure_avx2))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['use_avx512']:
            self._write_strip("unset PKG_CONFIG_PATH")
            self._write_strip("pushd ../buildavx512/" + self.subdir)
            self.write_build_prepend()
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=skylake-avx512 -mprefer-vector-width=512\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=skylake-avx512 -mprefer-vector-width=512\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=skylake-avx512\"")
            self._write_strip("%reconfigure {0} {1} {2} "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure_avx512))
            self.write_make_line()
            self._write_strip("popd")

        self._write_strip("\n")
        self.write_check()
        self.write_make_install()

    def write_make_pattern(self):
        """Write build pattern for make."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self.write_make_line()
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("\n")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self.write_32bit_exports()
            self.write_make_line(True)
            self._write_strip("popd")
        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2" + self.subdir)
            self.write_build_prepend()
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=haswell\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=haswell\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=haswell\"")
            self.write_make_line()
            self._write_strip("popd")
        if config.config_opts['use_avx512']:
            self._write_strip("pushd ../buildavx512" + self.subdir)
            self.write_build_prepend()
            self._write_strip("export CFLAGS=\"$CFLAGS -m64 -march=skylake-avx512 -mprefer-vector-width=512\"")
            self._write_strip("export CXXFLAGS=\"$CXXFLAGS -m64 -march=skylake-avx512 -mprefer-vector-width=512\"")
            self._write_strip("export LDFLAGS=\"$LDFLAGS -m64 -march=skylake-avx512\"")
            self.write_make_line()
            self._write_strip("popd")

        self._write_strip("\n")
        self.write_check()
        self.write_make_install()

    def write_autogen_pattern(self):
        """Write build pattern for autogen packages."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        if config.profile_payload and config.profile_payload[0]:
            self._write_strip("{0}%autogen {1} {2} {3}"
                              .format(self.get_profile_generate_flags(),
                                      self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure64))
            self.write_make_line()
            self._write_strip("\n")

            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")

        self._write_strip("{0}%autogen {1} {2} {3}"
                          .format(self.get_profile_use_flags(),
                                  self.disable_static,
                                  config.extra_configure,
                                  config.extra_configure64))
        self.write_make_line()
        self._write_strip("\n")
        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32/" + self.subdir)
            self.write_build_prepend()
            self.write_32bit_exports()
            self._write_strip("%autogen {0} {1} {2} "
                              "--libdir=/usr/lib32 "
                              "--build=i686-generic-linux-gnu "
                              "--host=i686-generic-linux-gnu "
                              "--target=i686-clr-linux-gnu"
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure32))
            self.write_make_line(True)
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2/" + self.subdir)
            self.write_build_prepend()
            self._write_strip('export CFLAGS="$CFLAGS -m64 -march=haswell "')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -m64 -march=haswell "')
            self._write_strip('export LDFLAGS="$LDFLAGS -m64 -march=haswell "')
            self._write_strip("%autogen {0} {1} {2} "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure_avx2))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['use_avx512']:
            self._write_strip("pushd ../buildavx512/" + self.subdir)
            self.write_build_prepend()
            self._write_strip('export CFLAGS="$CFLAGS -m64 -march=skylake-avx512 "')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -m64 -march=skylake-avx512 "')
            self._write_strip('export LDFLAGS="$LDFLAGS -m64 -march=skylake-avx512 "')
            self._write_strip("%autogen {0} {1} {2} "
                              .format(self.disable_static,
                                      config.extra_configure,
                                      config.extra_configure_avx512))
            self.write_make_line()
            self._write_strip("popd")

        self.write_check()
        self.write_make_install()

    def write_distutils_pattern(self):
        """Write build pattern for python packages using distutils."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip("export MAKEFLAGS=%{?_smp_mflags}")
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python2 setup.py build -b py2 " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("%install")
        self._write_strip("export MAKEFLAGS=%{?_smp_mflags}")
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()

        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python2 -tt setup.py build -b py2 install --root=%{buildroot}")
        if self.subdir:
            self._write_strip("popd")
        self.write_find_lang()

    def write_distutils3_pattern(self):
        """Write build pattern for python packages using distutils3."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip("export MAKEFLAGS=%{?_smp_mflags}")
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python3 setup.py build  " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("%install")
        self._write_strip("export MAKEFLAGS=%{?_smp_mflags}")
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()

        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python3 -tt setup.py build  install --root=%{buildroot}")
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("echo ----[ mark ]----")
        self._write_strip("cat %{buildroot}/usr/lib/python3*/site-packages/*/requires.txt || :")
        self._write_strip("echo ----[ mark ]----")
        self.write_find_lang()

    def write_distutils23_pattern(self):
        """Write build pattern for python packages using distutils2 and 32 and 3."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python2 setup.py build -b py2 " + config.extra_configure)
        self._write_strip("python3 setup.py build -b py3 " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("%install")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()

        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python2 -tt setup.py build -b py2 install --root=%{buildroot} --force")
        self._write_strip("python3 -tt setup.py build -b py3 install --root=%{buildroot} --force")
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("echo ----[ mark ]----")
        self._write_strip("cat %{buildroot}/usr/lib/python3*/site-packages/*/requires.txt || :")
        self._write_strip("echo ----[ mark ]----")
        self.write_find_lang()

    def write_distutils36_pattern(self):
        """Write build pattern for python packages using distutils36."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python3.6 setup.py build -b py3 " + config.extra_configure)
        self._write_strip("\n")
        if self.tests_config and not config.config_opts['skip_tests']:
            self._write_strip("%check")
            # Prevent setuptools from hitting the internet
            self.write_proxy_exports()
            self._write_strip(self.tests_config)
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("%install")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()

        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")

        if self.subdir:
            self._write_strip("pushd " + self.subdir)
        self._write_strip("python3.6 -tt setup.py build -b py3 install --root=%{buildroot} --force")
        if self.subdir:
            self._write_strip("popd")
        self._write_strip("echo ----[ mark ]----")
        self._write_strip("cat %{buildroot}/usr/lib/python3*/site-packages/*/requires.txt || :")
        self._write_strip("echo ----[ mark ]----")
        self.write_find_lang()

    def write_R_pattern(self):
        """Write build pattern for R packages."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self._write_strip("\n")

        self._write_strip("%install")
        self._write_strip("export SOURCE_DATE_EPOCH={}".format(int(time.time())))
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()
        self._write_strip("export LANG=C.UTF-8")
        self._write_strip('export CFLAGS="$CFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip('export FCFLAGS="$CFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip('export FFLAGS="$CFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip('export CXXFLAGS="$CXXFLAGS -O3 -flto -fno-semantic-interposition "\n')
        self._write_strip("export AR=gcc-ar\n")
        self._write_strip("export RANLIB=gcc-ranlib\n")
        self._write_strip('export LDFLAGS="$LDFLAGS  -Wl,-z -Wl,relro"\n')

        self._write_strip("mkdir -p %{buildroot}/usr/lib64/R/library")
        self._write_strip("\n")
        self._write_strip("mkdir -p ~/.R")
        self._write_strip("mkdir -p ~/.stash")

        self._write_strip("echo \"CFLAGS = $CFLAGS -march=haswell -ftree-vectorize \" > ~/.R/Makevars")
        self._write_strip("echo \"FFLAGS = $FFLAGS -march=haswell -ftree-vectorize \" >> ~/.R/Makevars")
        self._write_strip("echo \"CXXFLAGS = $CXXFLAGS -march=haswell -ftree-vectorize \" >> ~/.R/Makevars")

        self._write_strip("R CMD INSTALL "
                          "--install-tests "
                          "--built-timestamp=${SOURCE_DATE_EPOCH} "
                          "--build  -l "
                          "%{buildroot}/usr/lib64/R/library " + self.rawname)
        self._write_strip("for i in `find %{buildroot}/usr/lib64/R/ -name \"*.so\"`; do mv $i $i.avx2 ; mv $i.avx2 ~/.stash/; done\n")

        self._write_strip("echo \"CFLAGS = $CFLAGS -march=skylake-avx512 -ftree-vectorize \" > ~/.R/Makevars")
        self._write_strip("echo \"FFLAGS = $FFLAGS -march=skylake-avx512 -ftree-vectorize \" >> ~/.R/Makevars")
        self._write_strip("echo \"CXXFLAGS = $CXXFLAGS -march=skylake-avx512 -ftree-vectorize \" >> ~/.R/Makevars")

        self._write_strip("R CMD INSTALL "
                          "--preclean "
                          "--install-tests "
                          "--no-test-load "
                          "--built-timestamp=${SOURCE_DATE_EPOCH} "
                          "--build  -l "
                          "%{buildroot}/usr/lib64/R/library " + self.rawname)
        self._write_strip("for i in `find %{buildroot}/usr/lib64/R/ -name \"*.so\"`; do mv $i $i.avx512 ; mv $i.avx512 ~/.stash/; done\n")

        self._write_strip("echo \"CFLAGS = $CFLAGS -ftree-vectorize \" > ~/.R/Makevars")
        self._write_strip("echo \"FFLAGS = $FFLAGS -ftree-vectorize \" >> ~/.R/Makevars")
        self._write_strip("echo \"CXXFLAGS = $CXXFLAGS -ftree-vectorize \" >> ~/.R/Makevars")

        self._write_strip("R CMD INSTALL "
                          "--preclean "
                          "--install-tests "
                          "--built-timestamp=${SOURCE_DATE_EPOCH} "
                          "--build  -l "
                          "%{buildroot}/usr/lib64/R/library " + self.rawname)
        self._write_strip("cp ~/.stash/* %{buildroot}/usr/lib64/R/library/*/libs/ || :")

        self._write_strip("%{__rm} -rf %{buildroot}%{_datadir}/R/library/R.css")
        self.write_find_lang()
        self.write_check()

    def write_ruby_pattern(self):
        """Write build pattern for ruby packages."""
        self.write_prep(ruby_pattern=True)
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("export LANG=C.UTF-8")
        self._write_strip("gem build {}.gemspec".format(self.name))
        self._write_strip("\n")

        self._write_strip("%install")
        self.write_install_prepend()
        self._write_strip("%global gem_dir $(ruby -e'puts Gem.default_dir')")
        self._write_strip("gem install -V \\")
        self._write_strip("  --local \\")
        self._write_strip("  --force \\")
        self._write_strip("  --install-dir .%{gem_dir} \\")
        self._write_strip("  --bindir .%{_bindir} \\")
        self._write_strip(" {}.gem".format(self.tarball_prefix))
        self._write_strip("\n")

        self._write_strip("mkdir -p %{buildroot}%{gem_dir}")
        self._write_strip("cp -pa .%{gem_dir}/* \\")
        self._write_strip("        %{buildroot}%{gem_dir}")
        self._write_strip("\n")

        self._write_strip("if [ -d .%{_bindir} ]; then")
        self._write_strip("    mkdir -p %{buildroot}%{_bindir}")
        self._write_strip("    cp -pa .%{_bindir}/* \\")
        self._write_strip("        %{buildroot}%{_bindir}/")
        self._write_strip("fi")
        self._write_strip("\n")
        self.write_find_lang()
        self.write_check()

    def write_cmake_pattern(self):
        """Write cmake pattern to spec file."""
        if self.extra_make == "" or self.extra_cmake == " ":
            self.extra_make = "VERBOSE=1"
        self.write_prep()
        self.write_lang_c(export_epoch=True)

        if self.subdir:
            self._write_strip("pushd " + self.subdir)

        self._write_strip("mkdir -p clr-build")
        self._write_strip("pushd clr-build")
        self.write_variables()
        self._write_strip("%cmake {} {}".format(self.cmake_srcdir, self.extra_cmake))

        # Prep it for PGO
        if config.profile_payload and config.profile_payload[0]:
            self._write_strip("{0}".format(self.get_profile_generate_flags()))
            self.write_make_line()
            self._write_strip("\n".join(config.profile_payload))
            self._write_strip("\nmake clean\n")
            self._write_strip("{0}".format(self.get_profile_use_flags()))

        self.write_make_line()
        self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("mkdir -p clr-build-avx2")
            self._write_strip("pushd clr-build-avx2")
            saved_avx2flags = self.need_avx2_flags
            self.need_avx2_flags = True
            self.write_build_prepend()
            self.write_variables()
            self.need_avx2_flags = saved_avx2flags
            self._write_strip('export CFLAGS="$CFLAGS -march=haswell -m64"')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -march=haswell -m64"')
            self._write_strip("%cmake {} {}".format(self.cmake_srcdir, self.extra_cmake))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['use_avx512']:
            self._write_strip("mkdir -p clr-build-avx512")
            self._write_strip("pushd clr-build-avx512")
            saved_avx512flags = self.need_avx512_flags
            self.need_avx512_flags = True
            self.write_build_prepend()
            self.write_variables()
            self.need_avx512_flags = saved_avx512flags
            self._write_strip('export CFLAGS="$CFLAGS -march=skylake-avx512 -m64 "')
            self._write_strip('export CXXFLAGS="$CXXFLAGS -march=skylake-avx512 -m64 "')
            self._write_strip("%cmake {} {}".format(self.cmake_srcdir, self.extra_cmake))
            self.write_make_line()
            self._write_strip("popd")

        if config.config_opts['32bit']:
            self._write_strip("mkdir -p clr-build32")
            self._write_strip("pushd clr-build32")
            self.write_build_prepend()
            self.write_variables()
            self.write_32bit_exports()
            self._write_strip("%cmake -DLIB_INSTALL_DIR:PATH=/usr/lib32 "
                              "-DCMAKE_INSTALL_LIBDIR=/usr/lib32 "
                              "-DLIB_SUFFIX=32 "
                              "{} {} ".format(self.cmake_srcdir, self.extra_cmake))
            self.write_make_line()
            self._write_strip("unset PKG_CONFIG_PATH")
            self._write_strip("popd")

        if self.subdir:
            self._write_strip("popd")

        self._write_strip("\n")
        self.write_check()

        self.write_cmake_install()

    def write_qmake_pattern(self):
        """Write qmake build pattern to spec file."""
        extra_qmake_args = ""
        if config.config_opts['use_clang']:
            extra_qmake_args = "-spec linux-clang "
        if config.config_opts['use_lto']:
            extra_qmake_args += "-config ltcg -config fat-static-lto "
        else:
            extra_qmake_args += "QMAKE_CFLAGS+=-fno-lto QMAKE_CXXFLAGS+=-fno-lto "

        self.write_prep()
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("export LANG=C.UTF-8")
        self.write_variables()

        if self.subdir:
            self._write_strip("pushd " + self.subdir)

        self._write_strip("%qmake {}{}".format(extra_qmake_args, config.extra_configure))
        self._write_strip("test -r config.log && cat config.log")
        self.write_make_line()

        if self.subdir:
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip("pushd ../buildavx2/" + self.subdir)
            self.write_build_prepend()
            self._write("%qmake 'QT_CPU_FEATURES.x86_64 += avx avx2 bmi bmi2 f16c fma lzcnt popcnt'\\\n")
            self._write("    QMAKE_CFLAGS+=-march=haswell QMAKE_CXXFLAGS+=-march=haswell \\\n")
            self._write("    QMAKE_LFLAGS+=-march=haswell {}{}\n".format(extra_qmake_args, config.extra_configure))
            self.write_make_line()
            self._write_strip("popd")

        self._write_strip("\n")
        self.write_make_install()

    def write_cargo_pattern(self):
        """Write cargo build pattern to spec file."""
        self.write_prep()
        src_dir = "/usr/share/rust/src/{0}".format(self.name)
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("mkdir .cargo")
        self._write("echo \"[source.crates-io]\nreplace-with = 'vendored-sources'\n[source.vendored-sources]\ndirectory = '{}'\" > .cargo/config\n".format(os.path.dirname(src_dir)))
        self._write_strip('echo \'{"files":{},"package":""}\' > .cargo-checksum.json')
        # Don't let cargo get outside
        self._write_strip("export http_proxy=http://127.0.0.1:9/")
        self._write_strip("export https_proxy=http://127.0.0.1:9/")
        self._write_strip("export no_proxy=localhost,127.0.0.1,0.0.0.0")
        self._write_strip("cargo build --release")
        self._write_strip("\n")
        self._write_strip("%install")
        self.write_install_prepend()
        if self.cargo_bin:
            self._write_strip("cargo install --frozen --root /")
        self._write_strip("cargo clean")
        self._write_strip("install -d -p %{buildroot}" + src_dir)
        self._write_strip("cp -a . %{buildroot}" + src_dir)

    def write_cpan_pattern(self):
        """Write cpan build pattern to spec file."""
        self.write_prep()
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("export LANG=C.UTF-8")
        self._write_strip("if test -f Makefile.PL; then")
        self._write_strip("%{__perl} Makefile.PL")
        self.write_make_line()
        self._write_strip("else")
        self._write_strip("%{__perl} Build.PL")
        self._write_strip("./Build")
        self._write_strip("fi")
        self._write_strip("\n")
        self.write_check()
        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()
        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")
        self._write_strip("if test -f Makefile.PL; then")
        self._write_strip("make pure_install PERL_INSTALL_ROOT=%{buildroot} INSTALLDIRS=vendor")
        self._write_strip("else")
        self._write_strip("./Build install --installdirs=vendor --destdir=%{buildroot}")
        self._write_strip("fi")
        self._write_strip("find %{buildroot} -type f -name .packlist -exec rm -f {} ';'")
        self._write_strip("find %{buildroot} -depth -type d -exec rmdir {} 2>/dev/null ';'")
        self._write_strip("find %{buildroot} -type f -name '*.bs' -empty -exec rm -f {} ';'")
        self._write_strip("%{_fixperms} %{buildroot}/*")
        self.write_find_lang()

    def write_scons_pattern(self):
        """Write scons build pattern to spec file."""
        self.write_prep()
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("export LANG=C.UTF-8")
        self.write_variables()
        self._write_strip("scons{} {}".format(config.parallel_build, config.extra_configure))
        self._write_strip("\n")
        self._write_strip("%install")
        self.write_install_prepend()
        self._write_strip("scons install " + self.extra_make_install)
        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")

    def write_golang_pattern(self):
        """Write build pattern for go packages."""
        self.write_prep()
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("export LANG=C.UTF-8")
        if self.set_gopath:
            self._write_strip("export GOPATH=\"$PWD\"")
        self._write_strip("go build {}".format(self.extra_make))
        self._write_strip("\n")
        self._write_strip("%install")
        self._write_strip("rm -rf %{buildroot}")
        self.write_install_prepend()
        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")
        self._write_strip("\n")

    def write_maven_pattern(self):
        """Write maven build pattern to spec file."""

        self.write_prep()
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("mkdir %{buildroot}")
        self._write_strip("cp -r /usr/share/java/.m2 %{buildroot}/.m2")
        self._write_strip("mvn --offline -Dmaven.repo.local=%{buildroot}/.m2/repository " + self.extra_make)
        self._write_strip("\n")
        self._write_strip("%install")
        self.write_install_prepend()
        self._write_strip("")

    def write_mvnbin_pattern(self):
        """Write maven build pattern to spec file."""
        self._write_strip("%prep")
        self.write_prep_prepend()
        self._write_strip("\n")
        self._write_strip("%build")
        self.write_build_prepend()
        self._write_strip("\n")
        self._write_strip("%install")
        self.write_install_prepend()
        self.write_mvnbin_install()

    def write_meson_pattern(self):
        """Write meson build pattern to spec file."""
        self.write_prep()
        self.write_lang_c(export_epoch=True)
        self.write_variables()
        self._write_strip('CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" meson --prefix /usr --buildtype=plain {0} {1} builddir'
                          .format(config.extra_configure,
                                  config.extra_configure64))
        self._write_strip("ninja -v -C builddir")

        if config.config_opts['use_avx2']:
            self._write_strip('CFLAGS="$CFLAGS -m64 -march=haswell" CXXFLAGS="$CXXFLAGS -m64 -march=haswell " LDFLAGS="$LDFLAGS -m64 -march=haswell" '
                              'meson --prefix /usr --libdir=/usr/lib64/haswell --buildtype=plain {0} '
                              '{1} builddiravx2'.format(config.extra_configure, config.extra_configure64))
            self._write_strip('ninja -v -C builddiravx2')

        if config.config_opts['32bit']:
            self._write_strip("pushd ../build32")
            self.write_32bit_exports()
            self._write_strip('meson '
                              '--libdir=/usr/lib32 --prefix /usr --buildtype=plain {0} {1} builddir'
                              .format(config.extra_configure,
                                      config.extra_configure32))
            self._write_strip('ninja -v -C builddir')
            self._write_strip('popd')

        self._write_strip("\n")
        self.write_check()
        self._write_strip("%install")
        self.write_install_prepend()
        if len(self.license_files) > 0:
            self._write_strip("mkdir -p %{buildroot}/usr/share/package-licenses/" + self.name)
            for file in self.license_files:
                file2 = file.replace("/", "_")
                self._write_strip("cp " + file + " %{buildroot}/usr/share/package-licenses/" + self.name + "/" + file2 + "\n")
        if config.config_opts['32bit']:
            self._write_strip('pushd ../build32')
            self._write_strip('DESTDIR=%{buildroot} ninja -C builddir install')
            self._write_strip("if [ -d  %{buildroot}/usr/lib32/pkgconfig ]")
            self._write_strip("then")
            self._write_strip("    pushd %{buildroot}/usr/lib32/pkgconfig")
            self._write_strip("    for i in *.pc ; do ln -s $i 32$i ; done")
            self._write_strip("    popd")
            self._write_strip("fi")
            self._write_strip("popd")

        if config.config_opts['use_avx2']:
            self._write_strip('DESTDIR=%{buildroot} ninja -C builddiravx2 install')

        self._write_strip("DESTDIR=%{buildroot} ninja -C builddir install")
        self.write_find_lang()

    def write_phpize_pattern(self):
        """Write phpize build pattern to spec file."""
        self.write_prep()
        self._write_strip("%build")
        self.write_build_prepend()
        self.write_proxy_exports()
        self._write_strip("phpize")
        self._write_strip("%configure")
        self.write_make_line()
        self._write_strip("\n")
        self._write_strip("%install")
        self.write_install_prepend()
        self._write_strip("%make_install")
        self._write_strip("\n")

    def write_find_lang(self):
        """Write %find_lang macro to spec file."""
        for lang in self.locales:
            self._write("%find_lang {}\n".format(lang))

    def apply_patches(self):
        """Write patch list to spec file."""
        counter = 1
        for p in self.patches:
            name = p.split(None, 1)[0]
            if name == p:
                options = "-p1"
            else:
                options = p.split(None, 1)[1]
            if not p.split()[0].endswith(".nopatch"):
                self._write("%patch{} {}\n".format(counter, options))
            counter = counter + 1

    def _write(self, string):
        self.specfile.write(string)

    def _write_strip(self, string):
        self.specfile.write_strip(string)

    def quote_filename(self, filename):
        """Quotes the filename, if necessary. Identifies and skips any RPM directive prefix."""
        # Characters that require quoting -- only those with special
        # meaning in specfiles
        special_chars = set(" \t")
        # Build up the output as a string
        quoted = ''
        # Capture any directive prefix separately from actual filename
        #                          (1                   )(3 )
        directive_re = re.compile(r"(%\w+(\([^\)]*\))?\s+)(.*)")
        parts = directive_re.match(filename)
        if parts:
            # Add prefix to the output
            quoted += parts.group(1)
            # Set the filename to the remaining portion
            filename = parts.group(3)

        # Now check for special characters
        if any(c in filename for c in special_chars):
            # Quote the filename
            quoted += '"{}"'.format(filename)
        else:
            # Add the filename as-is
            quoted += filename
        return quoted
